# C언어 코드분석
`#include <stdio.h>`
`int main() {`
 `int result[5];`
 `int arr[5] = {77, 32, 10, 99, 50};`
 `for(int i= 0; i< 5; i++) {`
 `result[i] = 1;`
 `for(int j = 0; j < 5; j++) {`
 `if(arr[i] < arr[j]) {`
 `result[i]++;`
 `}`
 `}`
 `}`
 `for(int k = 0; k < 5; k++) {`
 `printf("%d ", result[k]);`
 `}`
 `return 0;`
`}`

1. 배열 초기화
    우선 두 개의 배열이 선언되었습니다:
    `int result[5];`
    `int arr[5] = {77, 32, 10, 99, 50};`
    arr[]: 정렬할 값들이 저장된 배열입니다. 이 배열의 값들은 {77, 32, 10, 99, 50}입니다.
    result[]: 각 값이 다른 값들과 비교되어 '순위'를 저장할 배열입니다. 처음에는 이 배열의 값을 모두 1로 초기화하게 됩니다.

2. 이중 루프를 통한 비교
다음으로 코드에서 이중 루프를 사용하여 각 배열 원소끼리 비교합니다.

외부 루프 (for (int i = 0; i < 5; i++))
이 루프는 arr[] 배열의 각 값을 하나씩 순회합니다. i는 현재 비교하고 있는 원소의 인덱스를 나타냅니다.

첫 번째 루프에서 i = 0, 즉 arr[0] = 77을 기준으로 비교가 이루어집니다.
두 번째 루프에서 i = 1, 즉 arr[1] = 32를 기준으로 비교합니다.
이렇게 반복해서 배열의 모든 값들을 차례로 기준으로 설정하고 다른 값들과 비교하게 됩니다.
내부 루프 (for (int j = 0; j < 5; j++))
각각의 arr[i] 값에 대해 arr[]의 다른 모든 값들과 비교하기 위해 내부 루프가 사용됩니다.

예를 들어, i = 0일 때 arr[0] = 77을 arr[0], arr[1], ..., arr[4]과 차례대로 비교합니다.
이때, arr[i]보다 큰 값이 있다면 result[i] 값을 하나씩 증가시킵니다. 즉, arr[i]가 얼마나 많은 값보다 작은지 체크하고 그만큼 순위가 밀리는 것이죠.
3. 순위 결정 방식
result[i] = 1로 시작하여, 각 arr[i]가 다른 arr[j]와 비교할 때 더 작다면 result[i] 값을 1씩 증가시킵니다. 이 과정은 배열의 값들이 다른 값들보다 얼마나 작은지에 따라 그 값의 순위가 결정되는 방식입니다.

예시로 첫 번째 반복을 살펴보면:

`for (int i = 0; i < 5; i++) {`
    `result[i] = 1; // 각 값에 대해 시작할 때 1로 초기화`
    `for (int j = 0; j < 5; j++) {`
        `if (arr[i] < arr[j]) {`
            `result[i]++;`
        `}`
    `}`
`}`
**첫 번째 비교 (i = 0):**

**arr[0] = 77과 다른 값들을 비교합니다:**
**77은 arr[1] = 32보다 크기 때문에 증가 없음.**
**77은 arr[2] = 10보다 크기 때문에 증가 없음.**
**77은 arr[3] = 99보다 작으므로 result[0]이 1에서 2로 증가.**
**77은 arr[4] = 50보다 크기 때문에 증가 없음.**
**최종적으로 result[0]은 3이 됩니다.**

**두 번째 비교 (i = 1):**

**arr[1] = 32와 다른 값들을 비교합니다:**
**32는 arr[0] = 77보다 작으므로 result[1]이 1에서 2로 증가.**
**32는 arr[2] = 10보다 크기 때문에 증가 없음.**
**32는 arr[3] = 99보다 작으므로 result[1]이 2에서 3으로 증가.**
**32는 arr[4] = 50보다 작으므로 result[1]이 3에서 4로 증가.**
**최종적으로 result[1]은 4가 됩니다.**

**세 번째 비교 (i = 2):**

**arr[2] = 10과 다른 값들을 비교합니다:**
**10은 arr[0] = 77보다 작으므로 result[2]이 1에서 2로 증가.**
**10은 arr[1] = 32보다 작으므로 result[2]이 2에서 3으로 증가.**
**10은 arr[3] = 99보다 작으므로 result[2]이 3에서 4로 증가.**
**10은 arr[4] = 50보다 작으므로 result[2]이 4에서 5로 증가.**
**최종적으로 result[2]은 5가 됩니다.**
**이런 식으로 나머지 값들도 모두 비교됩니다.**

4. 결과 출력
최종적으로 result[] 배열에 각 값의 순위가 저장됩니다. 마지막 for 루프에서 이를 출력합니다:


`for (int k = 0; k < 5; k++) {`
    `printf("%d ", result[k]);`
`}`

**77은 99보다 작으므로 3위입니다.**
**32는 77, 50, 99보다 작으므로 4위입니다.**
**10은 모든 값보다 작으므로 5위입니다.**
**99는 모든 값보다 크므로 1위입니다.**
**50은 77과 99보다 작으므로 2위입니다.**
**정리**
**이 코드는 각 배열 원소가 다른 원소와 비교하여 그 값이 얼마나 큰지에 대한 순위를 계산하는 방식입니다. 순위가 높을수록 result[i] 값이 작고, 순위가 낮을수록 result[i] 값이 커집니다.**
